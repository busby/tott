Syllabus
========

General Course Info
-------------------

:Term: 20XX
:Department: COMP
:Course Number: TBD
:Section Number: 001
:Time: TR, HH:MM â€“ HH:MM
:Location: TBD
:Announcements: In the `UNC TotT community on Google+ <https://plus.google.com/communities/110747799653894553777>`_

Instructor
----------

:Name: Peter Parente
:Office: N/A
:Email: parente@cs.unc.edu
:Office hours: in-person TBD, `Google Hangout TBD <https://plus.google.com/communities/110747799653894553777>`_

Course Description
------------------

Like most artisans, we software developers use many specialized tools to practice our craft. Tools to make our wares available to millions of users. Tools to store, search, analyze, and visualize vast amounts of data. Tools to convey information and insight to others. Tools to automate the repetitive and error prone. Tools to express our thought-stuff as functioning software. Tools that beget new tools. And like in other professions, not a one is a golden hammer. To build successfully, we must use appropriate tools.

Choosing the right instruments requires awareness of their existence, knowledge of their function, practice in their application, and evaluation of their alternatives. Here, our discipline presents both a unique opportunity and challenge: the population of tools at our immediate disposal is mind-boggling and growing at an accelerating pace. There is almost certainly a perfect combination of tools for every software development project, and there is almost certainly a project using any particular combination of tools. We cannot hope to master, let alone know about, all of them a priori. We must be nimble in our ability to find, learn, apply, and evaluate tools as the situation (our problem, our team, our client, our employer, etc.) demands.

.. figure:: _static/github.png
   :align: center
   :width: 600px
   :alt: Graph of GitHub repository growth since its inception.

   Numbers from `Wikipedia <https://en.wikipedia.org/wiki/GitHub#Statistics>`_ and its references.

I strongly believe practice "hacking" builds this agility. Taking time to discover a new tool, install it, run its "hello world", read its documentation, think about its use, create small examples, apply it to some pet project, compare it to other tools, and so on provides us invaluable experience. It builds our confidence so that we might step-up to unfamiliar tools, learn them quickly, and master them eventually. It adds tools to our belts, albeit few out of millions. It can fulfill our desire to learn and build new things.

Practice will be our routine in this course. The goal: to improve our ability to wield the endless tools of our trade.

Target Audience
---------------

You should consider taking this course if you:

* want a gently guided introduction to a variety of software tools,
* want dedicated class time to practice coding in a collaborative environment,
* want to improve your ability to tame unfamiliar languages and libraries, or
* think learning a bit about git, Python, jQuery, NodeJS, MongoDB, Sinatra, and other tools sounds like fun.

On the other hand, if you routinely play with new languages, contribute to open source, or hack weekend projects (e.g., `Arduino-powered laser harp? <http://www.youtube.com/watch?feature=player_embedded&v=sLVXmsbVwUs>`_), the pace and depth of this course may not suit you.

Prerequisites
-------------

I will assume that you have a strong understanding of core concepts in computer science such as those taught in COMP 401 (foundations), 410 (data structures and algs), and 411 (comp org). I will **not** assume you have a deep background in specific topics like those taught in COMP 426 (web), 521 (databases), or 530 (operating systems). A basic awareness of such topics is all you need to take this course.

Goals and Key Learning Objectives
---------------------------------

In teaching this course I hope to:

* Build your confidence in your own ability to learn, apply, integrate, and evaluate a variety of tools in your studies (e.g., COMP 523) and future professions,
* Introduce you to the growing diversity of tools used in software development, particularly in large distributed systems, and
* Expose you to the demands of polyglot development which requires experience in, or at least awareness of, a host of software, languages, libraries, processes, and disciplines.

By the end of this course you should be able to do the following:

* Work effectively at the command line
* Understand and use version control properly
* Write simple scripts and web apps in two or three dynamic languages
* Document, deploy, and share applications using automation
* Integrate tools to create applications of moderate size
* Evaluate tooling alternatives given a use case
* Approach new tools with confidence

Course Requirements
-------------------

Class Prep
~~~~~~~~~~

You must review the materials I post on this site before each class session. I will briefly review what I post here, but I will assume you've read through it. I want you to spend as much time as possible in class using the tools, helping one another, and asking me questions, **not** listening to me as I flip through charts.

You should also spend some time outside class researching tools on your own and sharing them in the class `Google+ community <TotT community>`_.

In-Class
~~~~~~~~

In nearly every class, we will:

#. Study a software development problem (e.g., I need to perform full-text search on a large set of documents)
#. Find and evaluate tools that might help solve the problem (e.g., Solr, Whoosh, Elasticsearch...)
#. Practice applying one of the tools to the problem (e.g., creating an index in Lucene)
#. Review the experience (e.g. applicability, learning curve, API quality, etc.)

**You must bring your laptop to every class session.** Getting practice finding, learning, applying, and evaluating tools quickly is the crux of the course.

You will document and share your work on the in-class exercises in the `TotT community`_. Occassionally, we will discuss your work at the end of our class sessions too. I will grade your class participation based on these contributions.

Assignments
~~~~~~~~~~~

You will complete a handful of programming assignments spread throughout the semester. The assignments will require integration of tools we cover in class and exploration of new tools on your own.

You will also complete a final project. The project will be similar to the assignments, but on a larger scale.

I will grade the assignments and final project against specs and test suites. I will make both available to you at the start of each assignment so that you have a continuous, objective measure of your progress.

Grading Criteria
----------------

I will determine final grades based on the following percentages:

* 55% programming assignments
* 30% final project
* 15% class attendance, participation, and effort

    * 10% for sharing your work on the in-class exercises
    * 3% for contributing to the class discussions
    * 2% for showing up to all classes

Policies
--------

Laptops
~~~~~~~

A carpenter goes to work with sharp saw, heavy hammer, and plentiful nails. You must come to class with your laptop, functioning and uncluttered, ready to experiment.

We will set up a virtual development environment on your laptop in the first few sessions. If you replace, lose, format, melt, etc. your laptop during the semester, you will need to work through the instructions again on your new machine in order to proceed.

Missing a Class
~~~~~~~~~~~~~~~

Attending and participating in class account for part of your grade. That said, if you miss a class due to extenuating circumstances, talk to me.

Late Assignments
~~~~~~~~~~~~~~~~

I will post assignments and their deadlines on this site, and announce them in the G+ community and in class. You will use git to submit your assignments. You can submit as many times as you wish. I will not grade your assignment until sometime after the due date and time. When I do, I'll grade your latest submission alone. If you haven't submitted anything by that time, you will get a zero on the assignment. I will not grant any other grace period.

So, submit early, submit often, and at the very least submit once!

Class Etiquette
~~~~~~~~~~~~~~~

Be respectful. Don't be late. Focus on the course material. Mute all noisy distractions. Leave the room if you have an important interrupt.

Exceptions
~~~~~~~~~~

I may make exceptions to the class policies in extreme circumstances. Talk with me if you need to deviate from policy.

Feedback
~~~~~~~~

If you have a suggestion, criticism, idea, or other piece of information you'd like to share with me about the course or my teaching, please let me know.

Collaboration and Resources
---------------------------

You may work with anyone and everyone on the in-class exercises. I will encourage entire class collaboration while we're learning together.

You may work with at most one partner from the class to complete the programming assignments and final project. If you do work with a partner, you must split the work roughly 50-50 on every assignment. You will submit one copy of your work using git which we'll review early in the course.

I encourage you to use tutorials, blogs, documentation, forums, online courseware, and any other technical materials you find ready-made on the web to complete the in-class exercises and at-home assignments in this course. (Google comes closest to being our golden hammer!) If you do, you must cite the resources you used in the README file you will submit in your completed assignments.

You are **forbidden**, however, from asking anyone other than your partner or me to help you solve the homework assignments verbatim. For example, posting the assignment to StackOverflow, whether someone responds with a solution or not, is clearly cheating and a violation of the honor code.

In all other respects, the `UNC Honor System <http://studentconduct.unc.edu/>`_ applies in this course.

Course Schedule
---------------

I plan to introduce the topics and tools in roughly the order listed on the :doc:`main page of this site <index>`. I've ordered the topics so that we have cycles of difficulty: we start simply, ramp up to harder topics, cool down with something easy, build up in complexity again, etc.

Disclaimer
----------

I reserve the right to change the syllabus, particularly the topic schedule and assignment due dates. I will let you know as far in advance as possible if I do.